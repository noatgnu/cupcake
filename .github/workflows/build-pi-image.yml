name: Build CUPCAKE Raspberry Pi Image

on:
  # Manual trigger with full configuration options
  workflow_dispatch:
    inputs:
      pi_model:
        description: 'Raspberry Pi Model'
        required: true
        default: 'both'
        type: choice
        options:
        - 'pi4'
        - 'pi5'
        - 'both'
      build_type:
        description: 'Build Type'
        required: true
        default: 'both'
        type: choice
        options:
        - 'lite'
        - 'desktop'
        - 'both'
      image_version:
        description: 'Image Version Tag'
        required: true
        default: 'latest'
        type: string
      enable_ssh:
        description: 'Enable SSH by default'
        required: true
        default: true
        type: boolean
      wifi_ssid:
        description: 'WiFi SSID (optional)'
        required: false
        type: string
      wifi_password:
        description: 'WiFi Password (optional)'
        required: false
        type: string
  
  # Automatic builds every 2 weeks (Sunday at 2 AM UTC)
  schedule:
    - cron: '0 2 * * 0/14'
  
  # Build and publish when a release is published
  release:
    types: [published]

jobs:
  build-pi4-desktop:
    if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && (inputs.pi_model == 'pi4' || inputs.pi_model == 'both') && (inputs.build_type == 'desktop' || inputs.build_type == 'both')) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    env:
      # Set defaults for scheduled/release builds
      PI_MODEL: ${{ github.event_name == 'workflow_dispatch' && inputs.pi_model || 'both' }}
      IMAGE_VERSION: ${{ github.event_name == 'workflow_dispatch' && inputs.image_version || (github.event_name == 'release' && github.ref_name || 'latest') }}
      ENABLE_SSH: ${{ github.event_name == 'workflow_dispatch' && inputs.enable_ssh || 'true' }}
      WIFI_SSID: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_ssid || '' }}
      WIFI_PASSWORD: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_password || '' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Free up disk space
      run: |
        # Remove large unused packages
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /usr/local/lib/python*
        sudo rm -rf /opt/az
        
        # Clean docker and system caches
        sudo docker image prune --all --force
        sudo apt-get clean
        sudo apt-get autoremove -y
        
        # Show available space
        df -h

    - name: Setup native pi-gen build environment
      run: |
        # Install required packages for native pi-gen build
        sudo apt-get update
        sudo apt-get install -y \
          binfmt-support qemu-user-static dos2unix \
          coreutils quilt parted qemu-user-static debootstrap zerofree zip \
          dosfstools libarchive-tools libcap2-bin grep rsync xz-utils file git curl bc \
          gpg pigz xxd arch-test debian-archive-keyring \
          wget parted gzip pigz xz-utils udev e2fsprogs
        
        # Setup binfmt for ARM emulation (required for native pi-gen)
        sudo modprobe binfmt_misc
        
        # Enable binfmt-support service
        sudo systemctl enable binfmt-support
        sudo systemctl start binfmt-support
        
        # Use update-binfmts to properly register ARM emulation
        sudo update-binfmts --enable qemu-arm || true
        sudo update-binfmts --enable qemu-aarch64 || true
        
        # Manual fallback registration if update-binfmts fails
        echo ':arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        echo ':aarch64:M::\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-aarch64-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        
        # Verify emulation is working
        echo "Checking ARM emulation:"
        ls -la /proc/sys/fs/binfmt_misc/
        
        # Test emulation functionality
        sudo dpkg --add-architecture armhf
        sudo dpkg --add-architecture arm64

    - name: Pre-build Frontend (x86 fast build)
      run: |
        cd raspberry-pi
        # Ensure script has correct line endings and is executable
        dos2unix prebuild-frontend.sh 2>/dev/null || true
        chmod +x prebuild-frontend.sh
        bash ./prebuild-frontend.sh --hostname cupcake-pi.local --output-dir ./frontend-dist
        
    - name: Build Pi 4 image using native pi-gen
      run: |
        # Clone official pi-gen repository
        git clone https://github.com/RPi-Distro/pi-gen.git
        cd pi-gen
        
        # Copy our custom stage as stage5 (after desktop installation)
        sudo cp -r ../stage2z-cupcake ./stage5
        
        # Remove any EXPORT_IMAGE files from intermediate stages to prevent multiple image creation
        sudo rm -f ./stage2/EXPORT_IMAGE || true
        sudo rm -f ./stage3/EXPORT_IMAGE || true
        sudo rm -f ./stage4/EXPORT_IMAGE || true
        
        # Create pi-gen config file
        cat > config <<EOF
        IMG_NAME=cupcake-pi4-desktop-${{ env.IMAGE_VERSION }}
        RELEASE=bookworm
        DEPLOY_COMPRESSION=xz
        COMPRESSION_LEVEL=9
        LOCALE_DEFAULT=en_US.UTF-8
        TARGET_HOSTNAME=cupcake-pi
        KEYBOARD_KEYMAP=gb
        KEYBOARD_LAYOUT="English (UK)"
        TIMEZONE_DEFAULT=UTC
        
        # User configuration
        FIRST_USER_NAME=cupcake
        FIRST_USER_PASS=cupcake123
        ENABLE_SSH=${{ env.ENABLE_SSH == 'true' && '1' || '0' }}
        
        # Build configuration
        WORK_DIR=\$(pwd)/work
        DEPLOY_DIR=\$(pwd)/deploy
        
        # Image size configuration (large size for full desktop + CUPCAKE)
        IMG_SIZE=16G
        BOOT_SIZE=512M
        
        # Stage configuration - run all stages including desktop with CUPCAKE
        # This creates a full Raspberry Pi OS Desktop with CUPCAKE pre-installed
        
        # Debootstrap configuration for better cross-architecture support
        BOOTSTRAP_KEYRING=debian-archive-keyring
        TARGET_ARCH=arm64
        
        # Export configuration - only export final image from stage5
        EXPORT_ROOTFS_DIR=stage5
        EOF
        
        # WiFi configuration (if provided)
        if [ -n "${{ env.WIFI_SSID }}" ]; then
          cat >> config <<EOF
        
        # WiFi configuration
        WPA_ESSID="${{ env.WIFI_SSID }}"
        WPA_PASSWORD="${{ env.WIFI_PASSWORD }}"
        WPA_COUNTRY=US
        EOF
        fi
        
        # Debug: Check what build scripts are available
        echo "Available build scripts:"
        ls -la build*.sh || true
        
        # Verify ARM emulation is working before build
        echo "Testing ARM emulation:"
        /usr/bin/qemu-arm-static --version || echo "ARM emulation not working"
        /usr/bin/qemu-aarch64-static --version || echo "AArch64 emulation not working"
        
        # Set up debootstrap to use QEMU emulation
        export DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static
        echo "DEBOOTSTRAP_QEMU_USER_STATIC set to: $DEBOOTSTRAP_QEMU_USER_STATIC"
        
        # Create any missing symlinks for debootstrap
        sudo mkdir -p /usr/lib/arch-test
        sudo ln -sf /usr/bin/qemu-aarch64-static /usr/lib/arch-test/ || true
        
        # Run native pi-gen build with monitoring
        echo "Starting native pi-gen build..."
        echo "Available disk space before build:"
        df -h
        
        # Run native pi-gen build (force native, not Docker) with timeout
        timeout 14400 sudo -E USE_DOCKER=0 DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static ./build.sh || {
          echo "Build timed out or failed"
          # Show any available logs
          find work/ -name "*.log" -exec echo "=== {} ===" \; -exec cat {} \; || true
          exit 1
        }
        
        # Check build results
        echo "Build completed, checking results:"
        echo "Checking if deploy directory exists:"
        if [ -d "deploy" ]; then
          ls -la deploy/
        else
          echo "ERROR: Deploy directory not found!"
          echo "Checking work directory structure:"
          find work/ -name "*.img*" -o -name "EXPORT*" 2>/dev/null || true
          echo "Checking all stage directories:"
          ls -la stage*/EXPORT* 2>/dev/null || true
          exit 1
        fi
        echo "Final disk space usage:"
        df -h
        
        # Use PiShrink to reduce image size
        echo "Using PiShrink to reduce image size..."
        cd deploy
        
        # Fix permissions and download PiShrink
        sudo chown -R $USER:$USER .
        wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
        chmod +x pishrink.sh
        
        # Check available disk space before processing
        echo "Available disk space before PiShrink:"
        df -h .
        
        for img in *.img.xz; do
          if [ -f "$img" ]; then
            echo "Processing $img with PiShrink..."
            
            # Get current compressed size
            compressed_size=$(stat -c%s "$img")
            echo "Current compressed size: $compressed_size bytes ($(($compressed_size / 1024 / 1024)) MB)"
            
            # Check if we have enough space (need ~3x the compressed size for safe processing)
            available_space=$(df --block-size=1 . | awk 'NR==2 {print $4}')
            required_space=$((compressed_size * 3))
            
            if [ $available_space -lt $required_space ]; then
              echo "WARNING: Insufficient disk space for PiShrink processing"
              echo "Available: $(($available_space / 1024 / 1024)) MB, Required: $(($required_space / 1024 / 1024)) MB"
              echo "Skipping PiShrink - using original pi-gen compressed image"
              continue
            fi
            
            # Decompress for PiShrink processing
            echo "Decompressing $img..."
            xz -d "$img"
            img_uncompressed="${img%.xz}"
            
            # Run PiShrink with xz compression (-Z option)
            echo "Running PiShrink on $img_uncompressed..."
            sudo ./pishrink.sh -Z "$img_uncompressed"
            
            # Check final size - PiShrink with -Z creates .img.xz directly
            if [ -f "${img_uncompressed}.xz" ]; then
              mv "${img_uncompressed}.xz" "$img"
              size=$(stat -c%s "$img")
              echo "PiShrink with xz compression: $size bytes ($(($size / 1024 / 1024)) MB)"
              echo "Space saved: $(($compressed_size - $size)) bytes"
            else
              # Fallback: PiShrink didn't create compressed output, compress with level 9
              echo "PiShrink didn't create compressed output, compressing with xz level 9..."
              xz -9 "$img_uncompressed"
              size=$(stat -c%s "$img")
              echo "Manual xz level 9 compression: $size bytes ($(($size / 1024 / 1024)) MB)"
            fi
          fi
        done
        
        echo "Final processed files:"
        ls -lah

    - name: Upload Pi 4 artifacts
      uses: actions/upload-artifact@v4
      with:
        name: cupcake-pi4-desktop-${{ env.IMAGE_VERSION }}
        path: pi-gen/deploy/*.img.xz
        retention-days: 30

  build-pi4-lite:
    if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && (inputs.pi_model == 'pi4' || inputs.pi_model == 'both') && (inputs.build_type == 'lite' || inputs.build_type == 'both')) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    env:
      # Set defaults for scheduled/release builds
      PI_MODEL: ${{ github.event_name == 'workflow_dispatch' && inputs.pi_model || 'both' }}
      BUILD_TYPE: 'lite'
      IMAGE_VERSION: ${{ github.event_name == 'workflow_dispatch' && inputs.image_version || (github.event_name == 'release' && github.ref_name || 'latest') }}
      ENABLE_SSH: ${{ github.event_name == 'workflow_dispatch' && inputs.enable_ssh || 'true' }}
      WIFI_SSID: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_ssid || '' }}
      WIFI_PASSWORD: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_password || '' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Free up disk space
      run: |
        # Remove large unused packages
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /usr/local/lib/python*
        sudo rm -rf /opt/az
        
        # Clean docker and system caches
        sudo docker image prune --all --force
        sudo apt-get clean
        sudo apt-get autoremove -y
        
        # Show available space
        df -h

    - name: Setup native pi-gen build environment
      run: |
        # Install required packages for native pi-gen build
        sudo apt-get update
        sudo apt-get install -y \
          binfmt-support qemu-user-static dos2unix \
          coreutils quilt parted qemu-user-static debootstrap zerofree zip \
          dosfstools libarchive-tools libcap2-bin grep rsync xz-utils file git curl bc \
          gpg pigz xxd arch-test debian-archive-keyring \
          wget parted gzip pigz xz-utils udev e2fsprogs
        
        # Setup binfmt for ARM emulation (required for native pi-gen)
        sudo modprobe binfmt_misc
        
        # Enable binfmt-support service
        sudo systemctl enable binfmt-support
        sudo systemctl start binfmt-support
        
        # Use update-binfmts to properly register ARM emulation
        sudo update-binfmts --enable qemu-arm || true
        sudo update-binfmts --enable qemu-aarch64 || true
        
        # Manual fallback registration if update-binfmts fails
        echo ':arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        echo ':aarch64:M::\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-aarch64-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        
        # Verify emulation is working
        echo "Checking ARM emulation:"
        ls -la /proc/sys/fs/binfmt_misc/
        
        # Test emulation functionality
        sudo dpkg --add-architecture armhf
        sudo dpkg --add-architecture arm64

    - name: Pre-build Frontend (x86 fast build)
      run: |
        cd raspberry-pi
        # Ensure script has correct line endings and is executable
        dos2unix prebuild-frontend.sh 2>/dev/null || true
        chmod +x prebuild-frontend.sh
        bash ./prebuild-frontend.sh --hostname cupcake-pi.local --output-dir ./frontend-dist
        
    - name: Build Pi 4 Lite image using native pi-gen
      run: |
        # Clone official pi-gen repository
        git clone https://github.com/RPi-Distro/pi-gen.git
        cd pi-gen
        
        # Copy our custom stage as stage3 (after stage2 lite)
        sudo cp -r ../stage2z-cupcake ./stage3
        
        # Ensure the EXPORT_IMAGE file is properly set for lite builds
        echo "IMG_SUFFIX=-cupcake" | sudo tee ./stage3/EXPORT_IMAGE
        
        # Remove any EXPORT_IMAGE files from intermediate stages to prevent multiple image creation
        sudo rm -f ./stage2/EXPORT_IMAGE || true
        sudo rm -f ./stage4/EXPORT_IMAGE || true
        sudo rm -f ./stage5/EXPORT_IMAGE || true
        
        # Create pi-gen config file for Lite build
        cat > config <<EOF
        IMG_NAME=cupcake-pi4-lite-${{ env.IMAGE_VERSION }}
        RELEASE=bookworm
        DEPLOY_COMPRESSION=xz
        COMPRESSION_LEVEL=9
        LOCALE_DEFAULT=en_US.UTF-8
        TARGET_HOSTNAME=cupcake-pi
        KEYBOARD_KEYMAP=gb
        KEYBOARD_LAYOUT="English (UK)"
        TIMEZONE_DEFAULT=UTC
        
        # User configuration
        FIRST_USER_NAME=cupcake
        FIRST_USER_PASS=cupcake123
        ENABLE_SSH=${{ env.ENABLE_SSH == 'true' && '1' || '0' }}
        
        # Build configuration
        WORK_DIR=\$(pwd)/work
        DEPLOY_DIR=\$(pwd)/deploy
        
        # Image size configuration (smaller for lite)
        IMG_SIZE=8G
        BOOT_SIZE=512M
        
        # Stage configuration - Lite build only (stop after stage3 with CUPCAKE)
        STAGE_LIST="stage0 stage1 stage2 stage3"
        
        # Debootstrap configuration for better cross-architecture support
        BOOTSTRAP_KEYRING=debian-archive-keyring
        TARGET_ARCH=arm64
        
        # Export configuration - only export final image from stage3
        EXPORT_ROOTFS_DIR=stage3
        EOF
        
        # WiFi configuration (if provided)
        if [ -n "${{ env.WIFI_SSID }}" ]; then
          cat >> config <<EOF
        
        # WiFi configuration
        WPA_ESSID="${{ env.WIFI_SSID }}"
        WPA_PASSWORD="${{ env.WIFI_PASSWORD }}"
        WPA_COUNTRY=US
        EOF
        fi
        
        # Debug: Check what build scripts are available
        echo "Available build scripts:"
        ls -la build*.sh || true
        
        # Verify ARM emulation is working before build
        echo "Testing ARM emulation:"
        /usr/bin/qemu-arm-static --version || echo "ARM emulation not working"
        /usr/bin/qemu-aarch64-static --version || echo "AArch64 emulation not working"
        
        # Set up debootstrap to use QEMU emulation
        export DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static
        echo "DEBOOTSTRAP_QEMU_USER_STATIC set to: $DEBOOTSTRAP_QEMU_USER_STATIC"
        
        # Create any missing symlinks for debootstrap
        sudo mkdir -p /usr/lib/arch-test
        sudo ln -sf /usr/bin/qemu-aarch64-static /usr/lib/arch-test/ || true
        
        # Run native pi-gen build with monitoring
        echo "Starting native pi-gen build..."
        echo "Available disk space before build:"
        df -h
        
        # Run native pi-gen build (force native, not Docker) with timeout
        timeout 14400 sudo -E USE_DOCKER=0 DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static ./build.sh || {
          echo "Build timed out or failed"
          # Show any available logs
          find work/ -name "*.log" -exec echo "=== {} ===" \; -exec cat {} \; || true
          exit 1
        }
        
        # Check build results
        echo "Build completed, checking results:"
        echo "Checking if deploy directory exists:"
        if [ -d "deploy" ]; then
          ls -la deploy/
        else
          echo "ERROR: Deploy directory not found!"
          echo "Checking work directory structure:"
          find work/ -name "*.img*" -o -name "EXPORT*" 2>/dev/null || true
          echo "Checking all stage directories:"
          ls -la stage*/EXPORT* 2>/dev/null || true
          exit 1
        fi
        echo "Final disk space usage:"
        df -h
        
        # Use PiShrink to reduce image size
        echo "Using PiShrink to reduce image size..."
        cd deploy
        
        # Fix permissions and download PiShrink
        sudo chown -R $USER:$USER .
        wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
        chmod +x pishrink.sh
        
        # Check available disk space before processing
        echo "Available disk space before PiShrink:"
        df -h .
        
        for img in *.img.xz; do
          if [ -f "$img" ]; then
            echo "Processing $img with PiShrink..."
            
            # Get current compressed size
            compressed_size=$(stat -c%s "$img")
            echo "Current compressed size: $compressed_size bytes ($(($compressed_size / 1024 / 1024)) MB)"
            
            # Check if we have enough space (need ~3x the compressed size for safe processing)
            available_space=$(df --block-size=1 . | awk 'NR==2 {print $4}')
            required_space=$((compressed_size * 3))
            
            if [ $available_space -lt $required_space ]; then
              echo "WARNING: Insufficient disk space for PiShrink processing"
              echo "Available: $(($available_space / 1024 / 1024)) MB, Required: $(($required_space / 1024 / 1024)) MB"
              echo "Skipping PiShrink - using original pi-gen compressed image"
              continue
            fi
            
            # Decompress for PiShrink processing
            echo "Decompressing $img..."
            xz -d "$img"
            img_uncompressed="${img%.xz}"
            
            # Run PiShrink with xz compression (-Z option)
            echo "Running PiShrink on $img_uncompressed..."
            sudo ./pishrink.sh -Z "$img_uncompressed"
            
            # Check final size - PiShrink with -Z creates .img.xz directly
            if [ -f "${img_uncompressed}.xz" ]; then
              mv "${img_uncompressed}.xz" "$img"
              size=$(stat -c%s "$img")
              echo "PiShrink with xz compression: $size bytes ($(($size / 1024 / 1024)) MB)"
              echo "Space saved: $(($compressed_size - $size)) bytes"
            else
              # Fallback: PiShrink didn't create compressed output, compress with level 9
              echo "PiShrink didn't create compressed output, compressing with xz level 9..."
              xz -9 "$img_uncompressed"
              size=$(stat -c%s "$img")
              echo "Manual xz level 9 compression: $size bytes ($(($size / 1024 / 1024)) MB)"
            fi
          fi
        done
        
        echo "Final processed files:"
        ls -lah

    - name: Upload Pi 4 Lite artifacts
      uses: actions/upload-artifact@v4
      with:
        name: cupcake-pi4-lite-${{ env.IMAGE_VERSION }}
        path: pi-gen/deploy/*.img.xz
        retention-days: 30

  build-pi5-desktop:
    if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && (inputs.pi_model == 'pi5' || inputs.pi_model == 'both') && (inputs.build_type == 'desktop' || inputs.build_type == 'both')) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    env:
      # Set defaults for scheduled/release builds
      PI_MODEL: ${{ github.event_name == 'workflow_dispatch' && inputs.pi_model || 'both' }}
      IMAGE_VERSION: ${{ github.event_name == 'workflow_dispatch' && inputs.image_version || (github.event_name == 'release' && github.ref_name || 'latest') }}
      ENABLE_SSH: ${{ github.event_name == 'workflow_dispatch' && inputs.enable_ssh || 'true' }}
      WIFI_SSID: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_ssid || '' }}
      WIFI_PASSWORD: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_password || '' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Free up disk space
      run: |
        # Remove large unused packages
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /usr/local/lib/python*
        sudo rm -rf /opt/az
        
        # Clean docker and system caches
        sudo docker image prune --all --force
        sudo apt-get clean
        sudo apt-get autoremove -y
        
        # Show available space
        df -h

    - name: Setup native pi-gen build environment
      run: |
        # Install required packages for native pi-gen build
        sudo apt-get update
        sudo apt-get install -y \
          binfmt-support qemu-user-static dos2unix \
          coreutils quilt parted qemu-user-static debootstrap zerofree zip \
          dosfstools libarchive-tools libcap2-bin grep rsync xz-utils file git curl bc \
          gpg pigz xxd arch-test debian-archive-keyring \
          wget parted gzip pigz xz-utils udev e2fsprogs
        
        # Setup binfmt for ARM emulation (required for native pi-gen)
        sudo modprobe binfmt_misc
        
        # Enable binfmt-support service
        sudo systemctl enable binfmt-support
        sudo systemctl start binfmt-support
        
        # Use update-binfmts to properly register ARM emulation
        sudo update-binfmts --enable qemu-arm || true
        sudo update-binfmts --enable qemu-aarch64 || true
        
        # Manual fallback registration if update-binfmts fails
        echo ':arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        echo ':aarch64:M::\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-aarch64-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        
        # Verify emulation is working
        echo "Checking ARM emulation:"
        ls -la /proc/sys/fs/binfmt_misc/
        
        # Test emulation functionality
        sudo dpkg --add-architecture armhf
        sudo dpkg --add-architecture arm64

    - name: Pre-build Frontend (x86 fast build)
      run: |
        cd raspberry-pi
        # Ensure script has correct line endings and is executable
        dos2unix prebuild-frontend.sh 2>/dev/null || true
        chmod +x prebuild-frontend.sh
        bash ./prebuild-frontend.sh --hostname cupcake-pi.local --output-dir ./frontend-dist
        
    - name: Build Pi 5 image using native pi-gen
      run: |
        # Clone official pi-gen repository
        git clone https://github.com/RPi-Distro/pi-gen.git
        cd pi-gen
        
        # Copy our custom stage as stage5 (after desktop installation)
        sudo cp -r ../stage2z-cupcake ./stage5
        
        # Remove any EXPORT_IMAGE files from intermediate stages to prevent multiple image creation
        sudo rm -f ./stage2/EXPORT_IMAGE || true
        sudo rm -f ./stage3/EXPORT_IMAGE || true
        sudo rm -f ./stage4/EXPORT_IMAGE || true
        
        # Create pi-gen config file
        cat > config <<EOF
        IMG_NAME=cupcake-pi5-desktop-${{ env.IMAGE_VERSION }}
        RELEASE=bookworm
        DEPLOY_COMPRESSION=xz
        COMPRESSION_LEVEL=9
        LOCALE_DEFAULT=en_US.UTF-8
        TARGET_HOSTNAME=cupcake-pi
        KEYBOARD_KEYMAP=gb
        KEYBOARD_LAYOUT="English (UK)"
        TIMEZONE_DEFAULT=UTC
        
        # User configuration
        FIRST_USER_NAME=cupcake
        FIRST_USER_PASS=cupcake123
        ENABLE_SSH=${{ env.ENABLE_SSH == 'true' && '1' || '0' }}
        
        # Build configuration
        WORK_DIR=\$(pwd)/work
        DEPLOY_DIR=\$(pwd)/deploy
        
        # Image size configuration (large size for full desktop + CUPCAKE)
        IMG_SIZE=16G
        BOOT_SIZE=512M
        
        # Stage configuration - run all stages including desktop with CUPCAKE
        # This creates a full Raspberry Pi OS Desktop with CUPCAKE pre-installed
        
        # Debootstrap configuration for better cross-architecture support
        BOOTSTRAP_KEYRING=debian-archive-keyring
        TARGET_ARCH=arm64
        
        # Export configuration - only export final image from stage5
        EXPORT_ROOTFS_DIR=stage5
        EOF
        
        # WiFi configuration (if provided)
        if [ -n "${{ env.WIFI_SSID }}" ]; then
          cat >> config <<EOF
        
        # WiFi configuration
        WPA_ESSID="${{ env.WIFI_SSID }}"
        WPA_PASSWORD="${{ env.WIFI_PASSWORD }}"
        WPA_COUNTRY=US
        EOF
        fi
        
        # Debug: Check what build scripts are available
        echo "Available build scripts:"
        ls -la build*.sh || true
        
        # Verify ARM emulation is working before build
        echo "Testing ARM emulation:"
        /usr/bin/qemu-arm-static --version || echo "ARM emulation not working"
        /usr/bin/qemu-aarch64-static --version || echo "AArch64 emulation not working"
        
        # Set up debootstrap to use QEMU emulation
        export DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static
        echo "DEBOOTSTRAP_QEMU_USER_STATIC set to: $DEBOOTSTRAP_QEMU_USER_STATIC"
        
        # Create any missing symlinks for debootstrap
        sudo mkdir -p /usr/lib/arch-test
        sudo ln -sf /usr/bin/qemu-aarch64-static /usr/lib/arch-test/ || true
        
        # Run native pi-gen build with monitoring
        echo "Starting native pi-gen build..."
        echo "Available disk space before build:"
        df -h
        
        # Run native pi-gen build (force native, not Docker) with timeout
        timeout 14400 sudo -E USE_DOCKER=0 DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static ./build.sh || {
          echo "Build timed out or failed"
          # Show any available logs
          find work/ -name "*.log" -exec echo "=== {} ===" \; -exec cat {} \; || true
          exit 1
        }
        
        # Check build results
        echo "Build completed, checking results:"
        echo "Checking if deploy directory exists:"
        if [ -d "deploy" ]; then
          ls -la deploy/
        else
          echo "ERROR: Deploy directory not found!"
          echo "Checking work directory structure:"
          find work/ -name "*.img*" -o -name "EXPORT*" 2>/dev/null || true
          echo "Checking all stage directories:"
          ls -la stage*/EXPORT* 2>/dev/null || true
          exit 1
        fi
        echo "Final disk space usage:"
        df -h
        
        # Use PiShrink to reduce image size
        echo "Using PiShrink to reduce image size..."
        cd deploy
        
        # Fix permissions and download PiShrink
        sudo chown -R $USER:$USER .
        wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
        chmod +x pishrink.sh
        
        # Check available disk space before processing
        echo "Available disk space before PiShrink:"
        df -h .
        
        for img in *.img.xz; do
          if [ -f "$img" ]; then
            echo "Processing $img with PiShrink..."
            
            # Get current compressed size
            compressed_size=$(stat -c%s "$img")
            echo "Current compressed size: $compressed_size bytes ($(($compressed_size / 1024 / 1024)) MB)"
            
            # Check if we have enough space (need ~3x the compressed size for safe processing)
            available_space=$(df --block-size=1 . | awk 'NR==2 {print $4}')
            required_space=$((compressed_size * 3))
            
            if [ $available_space -lt $required_space ]; then
              echo "WARNING: Insufficient disk space for PiShrink processing"
              echo "Available: $(($available_space / 1024 / 1024)) MB, Required: $(($required_space / 1024 / 1024)) MB"
              echo "Skipping PiShrink - using original pi-gen compressed image"
              continue
            fi
            
            # Decompress for PiShrink processing
            echo "Decompressing $img..."
            xz -d "$img"
            img_uncompressed="${img%.xz}"
            
            # Run PiShrink with xz compression (-Z option)
            echo "Running PiShrink on $img_uncompressed..."
            sudo ./pishrink.sh -Z "$img_uncompressed"
            
            # Check final size - PiShrink with -Z creates .img.xz directly
            if [ -f "${img_uncompressed}.xz" ]; then
              mv "${img_uncompressed}.xz" "$img"
              size=$(stat -c%s "$img")
              echo "PiShrink with xz compression: $size bytes ($(($size / 1024 / 1024)) MB)"
              echo "Space saved: $(($compressed_size - $size)) bytes"
            else
              # Fallback: PiShrink didn't create compressed output, compress with level 9
              echo "PiShrink didn't create compressed output, compressing with xz level 9..."
              xz -9 "$img_uncompressed"
              size=$(stat -c%s "$img")
              echo "Manual xz level 9 compression: $size bytes ($(($size / 1024 / 1024)) MB)"
            fi
          fi
        done
        
        echo "Final processed files:"
        ls -lah

    - name: Upload Pi 5 artifacts
      uses: actions/upload-artifact@v4
      with:
        name: cupcake-pi5-desktop-${{ env.IMAGE_VERSION }}
        path: pi-gen/deploy/*.img.xz
        retention-days: 30

  build-pi5-lite:
    if: ${{ github.event_name == 'schedule' || github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && (inputs.pi_model == 'pi5' || inputs.pi_model == 'both') && (inputs.build_type == 'lite' || inputs.build_type == 'both')) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    env:
      # Set defaults for scheduled/release builds
      PI_MODEL: ${{ github.event_name == 'workflow_dispatch' && inputs.pi_model || 'both' }}
      BUILD_TYPE: 'lite'
      IMAGE_VERSION: ${{ github.event_name == 'workflow_dispatch' && inputs.image_version || (github.event_name == 'release' && github.ref_name || 'latest') }}
      ENABLE_SSH: ${{ github.event_name == 'workflow_dispatch' && inputs.enable_ssh || 'true' }}
      WIFI_SSID: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_ssid || '' }}
      WIFI_PASSWORD: ${{ github.event_name == 'workflow_dispatch' && inputs.wifi_password || '' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Free up disk space
      run: |
        # Remove large unused packages
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /opt/ghc
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /usr/local/lib/python*
        sudo rm -rf /opt/az
        
        # Clean docker and system caches
        sudo docker image prune --all --force
        sudo apt-get clean
        sudo apt-get autoremove -y
        
        # Show available space
        df -h

    - name: Setup native pi-gen build environment
      run: |
        # Install required packages for native pi-gen build
        sudo apt-get update
        sudo apt-get install -y \
          binfmt-support qemu-user-static dos2unix \
          coreutils quilt parted qemu-user-static debootstrap zerofree zip \
          dosfstools libarchive-tools libcap2-bin grep rsync xz-utils file git curl bc \
          gpg pigz xxd arch-test debian-archive-keyring \
          wget parted gzip pigz xz-utils udev e2fsprogs
        
        # Setup binfmt for ARM emulation (required for native pi-gen)
        sudo modprobe binfmt_misc
        
        # Enable binfmt-support service
        sudo systemctl enable binfmt-support
        sudo systemctl start binfmt-support
        
        # Use update-binfmts to properly register ARM emulation
        sudo update-binfmts --enable qemu-arm || true
        sudo update-binfmts --enable qemu-aarch64 || true
        
        # Manual fallback registration if update-binfmts fails
        echo ':arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        echo ':aarch64:M::\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-aarch64-static:F' | sudo tee /proc/sys/fs/binfmt_misc/register || true
        
        # Verify emulation is working
        echo "Checking ARM emulation:"
        ls -la /proc/sys/fs/binfmt_misc/
        
        # Test emulation functionality
        sudo dpkg --add-architecture armhf
        sudo dpkg --add-architecture arm64

    - name: Pre-build Frontend (x86 fast build)
      run: |
        cd raspberry-pi
        # Ensure script has correct line endings and is executable
        dos2unix prebuild-frontend.sh 2>/dev/null || true
        chmod +x prebuild-frontend.sh
        bash ./prebuild-frontend.sh --hostname cupcake-pi.local --output-dir ./frontend-dist
        
    - name: Build Pi 5 Lite image using native pi-gen
      run: |
        # Clone official pi-gen repository
        git clone https://github.com/RPi-Distro/pi-gen.git
        cd pi-gen
        
        # Copy our custom stage as stage3 (after stage2 lite)
        sudo cp -r ../stage2z-cupcake ./stage3
        
        # Ensure the EXPORT_IMAGE file is properly set for lite builds
        echo "IMG_SUFFIX=-cupcake" | sudo tee ./stage3/EXPORT_IMAGE
        
        # Remove any EXPORT_IMAGE files from intermediate stages to prevent multiple image creation
        sudo rm -f ./stage2/EXPORT_IMAGE || true
        sudo rm -f ./stage4/EXPORT_IMAGE || true
        sudo rm -f ./stage5/EXPORT_IMAGE || true
        
        # Create pi-gen config file for Lite build
        cat > config <<EOF
        IMG_NAME=cupcake-pi5-lite-${{ env.IMAGE_VERSION }}
        RELEASE=bookworm
        DEPLOY_COMPRESSION=xz
        COMPRESSION_LEVEL=9
        LOCALE_DEFAULT=en_US.UTF-8
        TARGET_HOSTNAME=cupcake-pi
        KEYBOARD_KEYMAP=gb
        KEYBOARD_LAYOUT="English (UK)"
        TIMEZONE_DEFAULT=UTC
        
        # User configuration
        FIRST_USER_NAME=cupcake
        FIRST_USER_PASS=cupcake123
        ENABLE_SSH=${{ env.ENABLE_SSH == 'true' && '1' || '0' }}
        
        # Build configuration
        WORK_DIR=\$(pwd)/work
        DEPLOY_DIR=\$(pwd)/deploy
        
        # Image size configuration (smaller for lite)
        IMG_SIZE=8G
        BOOT_SIZE=512M
        
        # Stage configuration - Lite build only (stop after stage3 with CUPCAKE)
        STAGE_LIST="stage0 stage1 stage2 stage3"
        
        # Debootstrap configuration for better cross-architecture support
        BOOTSTRAP_KEYRING=debian-archive-keyring
        TARGET_ARCH=arm64
        
        # Export configuration - only export final image from stage3
        EXPORT_ROOTFS_DIR=stage3
        EOF
        
        # WiFi configuration (if provided)
        if [ -n "${{ env.WIFI_SSID }}" ]; then
          cat >> config <<EOF
        
        # WiFi configuration
        WPA_ESSID="${{ env.WIFI_SSID }}"
        WPA_PASSWORD="${{ env.WIFI_PASSWORD }}"
        WPA_COUNTRY=US
        EOF
        fi
        
        # Debug: Check what build scripts are available
        echo "Available build scripts:"
        ls -la build*.sh || true
        
        # Verify ARM emulation is working before build
        echo "Testing ARM emulation:"
        /usr/bin/qemu-arm-static --version || echo "ARM emulation not working"
        /usr/bin/qemu-aarch64-static --version || echo "AArch64 emulation not working"
        
        # Set up debootstrap to use QEMU emulation
        export DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static
        echo "DEBOOTSTRAP_QEMU_USER_STATIC set to: $DEBOOTSTRAP_QEMU_USER_STATIC"
        
        # Create any missing symlinks for debootstrap
        sudo mkdir -p /usr/lib/arch-test
        sudo ln -sf /usr/bin/qemu-aarch64-static /usr/lib/arch-test/ || true
        
        # Run native pi-gen build with monitoring
        echo "Starting native pi-gen build..."
        echo "Available disk space before build:"
        df -h
        
        # Run native pi-gen build (force native, not Docker) with timeout
        timeout 14400 sudo -E USE_DOCKER=0 DEBOOTSTRAP_QEMU_USER_STATIC=/usr/bin/qemu-aarch64-static ./build.sh || {
          echo "Build timed out or failed"
          # Show any available logs
          find work/ -name "*.log" -exec echo "=== {} ===" \; -exec cat {} \; || true
          exit 1
        }
        
        # Check build results
        echo "Build completed, checking results:"
        echo "Checking if deploy directory exists:"
        if [ -d "deploy" ]; then
          ls -la deploy/
        else
          echo "ERROR: Deploy directory not found!"
          echo "Checking work directory structure:"
          find work/ -name "*.img*" -o -name "EXPORT*" 2>/dev/null || true
          echo "Checking all stage directories:"
          ls -la stage*/EXPORT* 2>/dev/null || true
          exit 1
        fi
        echo "Final disk space usage:"
        df -h
        
        # Use PiShrink to reduce image size
        echo "Using PiShrink to reduce image size..."
        cd deploy
        
        # Fix permissions and download PiShrink
        sudo chown -R $USER:$USER .
        wget https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
        chmod +x pishrink.sh
        
        # Check available disk space before processing
        echo "Available disk space before PiShrink:"
        df -h .
        
        for img in *.img.xz; do
          if [ -f "$img" ]; then
            echo "Processing $img with PiShrink..."
            
            # Get current compressed size
            compressed_size=$(stat -c%s "$img")
            echo "Current compressed size: $compressed_size bytes ($(($compressed_size / 1024 / 1024)) MB)"
            
            # Check if we have enough space (need ~3x the compressed size for safe processing)
            available_space=$(df --block-size=1 . | awk 'NR==2 {print $4}')
            required_space=$((compressed_size * 3))
            
            if [ $available_space -lt $required_space ]; then
              echo "WARNING: Insufficient disk space for PiShrink processing"
              echo "Available: $(($available_space / 1024 / 1024)) MB, Required: $(($required_space / 1024 / 1024)) MB"
              echo "Skipping PiShrink - using original pi-gen compressed image"
              continue
            fi
            
            # Decompress for PiShrink processing
            echo "Decompressing $img..."
            xz -d "$img"
            img_uncompressed="${img%.xz}"
            
            # Run PiShrink with xz compression (-Z option)
            echo "Running PiShrink on $img_uncompressed..."
            sudo ./pishrink.sh -Z "$img_uncompressed"
            
            # Check final size - PiShrink with -Z creates .img.xz directly
            if [ -f "${img_uncompressed}.xz" ]; then
              mv "${img_uncompressed}.xz" "$img"
              size=$(stat -c%s "$img")
              echo "PiShrink with xz compression: $size bytes ($(($size / 1024 / 1024)) MB)"
              echo "Space saved: $(($compressed_size - $size)) bytes"
            else
              # Fallback: PiShrink didn't create compressed output, compress with level 9
              echo "PiShrink didn't create compressed output, compressing with xz level 9..."
              xz -9 "$img_uncompressed"
              size=$(stat -c%s "$img")
              echo "Manual xz level 9 compression: $size bytes ($(($size / 1024 / 1024)) MB)"
            fi
          fi
        done
        
        echo "Final processed files:"
        ls -lah

    - name: Upload Pi 5 Lite artifacts
      uses: actions/upload-artifact@v4
      with:
        name: cupcake-pi5-lite-${{ env.IMAGE_VERSION }}
        path: pi-gen/deploy/*.img.xz
        retention-days: 30

  create-release:
    if: ${{ github.event_name == 'release' }}
    needs: [build-pi4-desktop, build-pi4-lite, build-pi5-desktop, build-pi5-lite]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Download Pi 4 Desktop artifacts
      uses: actions/download-artifact@v4
      with:
        name: cupcake-pi4-desktop-${{ github.ref_name }}
        path: ./release-artifacts/

    - name: Download Pi 5 Desktop artifacts
      uses: actions/download-artifact@v4
      with:
        name: cupcake-pi5-desktop-${{ github.ref_name }}
        path: ./release-artifacts/

    - name: Download Pi 4 Lite artifacts
      uses: actions/download-artifact@v4
      with:
        name: cupcake-pi4-lite-${{ github.ref_name }}
        path: ./release-artifacts/

    - name: Download Pi 5 Lite artifacts
      uses: actions/download-artifact@v4
      with:
        name: cupcake-pi5-lite-${{ github.ref_name }}
        path: ./release-artifacts/

    - name: Create release notes
      run: |
        cat > release-notes.md << 'EOF'
        # CUPCAKE Raspberry Pi Images - ${{ github.ref_name }}
        
        Full Raspberry Pi OS Desktop images with CUPCAKE Laboratory Information Management System pre-installed using traditional pi-gen build process.
        
        ## ðŸŽ¯ Features
        
        - **Full Desktop Environment** - Complete Raspberry Pi OS Desktop with GUI
        - **Native CUPCAKE LIMS** - Direct Python deployment (no Docker)
        - **PostgreSQL & Redis** - Native database and caching services
        - **Nginx** - High-performance web server
        - **Desktop Integration** - CUPCAKE accessible via desktop browser
        - **Security hardened** - SSH configured, fail2ban ready
        - **NVMe optimized** - High-performance storage support
        - **Auto-setup service** - Completes installation on first boot
        - **Performance tuned** - Optimized for each Pi model
        
        ## ðŸ“‹ What's Included
        
        ### Pi 4 Edition
        - ARM64 Raspberry Pi OS Desktop (Full GUI)
        - 2.0GHz overclock with cooling optimization  
        - 128MB GPU memory allocation for desktop
        - NVMe support with PCIe optimizations
        - Python 3, PostgreSQL 14, Redis, Nginx
        - Desktop browser with CUPCAKE pre-configured
        - Traditional system service deployment
        - Built using official pi-gen Docker process
        
        ### Pi 5 Edition  
        - ARM64 Raspberry Pi OS Desktop (Full GUI)
        - 2.4GHz overclock with advanced cooling
        - 256MB GPU memory allocation for desktop
        - PCIe Gen 3 NVMe support
        - Python 3, PostgreSQL, Redis, Nginx
        - Desktop browser with CUPCAKE pre-configured
        - Traditional system service deployment
        
        ## ðŸš€ Quick Start
        
        1. **Flash image** to SD card or NVMe drive using Raspberry Pi Imager
        2. **Boot your Pi** - First boot will take 5-10 minutes for setup
        3. **SSH in**: `ssh cupcake@cupcake-pi4.local` (or cupcake-pi5.local)
        4. **Check status**: `sudo systemctl status cupcake-setup`
        5. **Access CUPCAKE**: http://your-pi-ip (port configured during setup)
        
        ## ðŸ” Default Credentials
        
        - **Username**: `cupcake`
        - **Password**: `cupcake123` (change immediately after first login)
        - **SSH**: Enabled by default
        
        ## ðŸ“Š System Requirements
        
        ### Minimum (Pi 4 Desktop)
        - Raspberry Pi 4B 8GB RAM (required for desktop + CUPCAKE)
        - 256GB+ storage (NVMe SSD strongly recommended)
        - Reliable power supply (official adapter recommended)
        - Monitor, keyboard, mouse for desktop use
        - Ethernet or WiFi connection
        
        ### Recommended (Pi 5 Desktop)
        - Raspberry Pi 5 8GB RAM
        - 500GB+ NVMe SSD 
        - Official Pi 5 power supply
        - Active cooling solution
        - 4K monitor support
        - Ethernet connection for best performance
        
        ## ðŸ”§ Post-Installation
        
        After first boot, run these commands:
        
        ```bash
        # Check setup status
        sudo systemctl status cupcake-setup.service
        
        # View setup logs
        sudo journalctl -u cupcake-setup.service -f
        
        # Check CUPCAKE services
        sudo systemctl status postgresql redis-server nginx
        
        # Monitor system resources
        htop
        ```
        
        ## ðŸ“– Documentation
        
        - [CUPCAKE Documentation](https://github.com/noatgnu/cupcake)
        - [Raspberry Pi Deployment Guide](https://github.com/noatgnu/cupcake/tree/master/raspberry-pi)
        - [Traditional Pi Deployment](https://github.com/noatgnu/cupcake/blob/master/raspberry-pi/README.md)
        
        ## ðŸ†˜ Support
        
        - [GitHub Issues](https://github.com/noatgnu/cupcake/issues)
        - [Community Discord](https://discord.gg/cupcake-lims)
        
        ---
        
        **âš ï¸ Important**: This uses traditional pi-gen build process with native system services (no Docker). Change default passwords immediately after installation!
        EOF

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.ref_name }}
        name: CUPCAKE Pi Images ${{ github.ref_name }}
        body_path: release-notes.md
        files: |
          release-artifacts/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup:
    if: always()
    needs: [build-pi4-desktop, build-pi4-lite, build-pi5-desktop, build-pi5-lite, create-release]
    runs-on: ubuntu-latest
    
    steps:
    - name: Cleanup build artifacts
      run: |
        echo "ðŸ§¹ Cleaning up build artifacts..."
        # GitHub automatically cleans up artifacts after retention period
        # This is just a placeholder for any additional cleanup needed